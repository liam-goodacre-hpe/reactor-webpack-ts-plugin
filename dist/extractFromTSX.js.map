{"version":3,"file":"extractFromTSX.js","sourceRoot":"","sources":["../src/extractFromTSX.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript'\nimport { SyntaxKind } from 'typescript'\n\nconst REACTIFY = 'reactify'\nconst REACTOR_MODULE_PATTERN = /^@extjs\\/reactor$/\nconst COMPONENT_MODULE_PATTERN = /^@extjs\\/reactor\\/(modern|classic)$/\n\n/**\n * Extracts Ext.create equivalents from jsx tags so that cmd knows which classes to include in the bundle\n * @param {String} js The javascript code\n * @param {String} prefix The prefix that denotes an Ext JS xtype\n * @returns {Array} An array of Ext.create statements\n */\nexport default function extractFromTSX(source, scriptTarget: ts.ScriptTarget) {\n  // need to specify the filename as *.tsx for tsc to parse JSX tags\n  const sourceFile = ts.createSourceFile('foo.tsx', source, scriptTarget)\n  const statements: string[] = []\n  const types = {}\n  let reactifyNames: string[] = []\n  let reactorNames: string[] = []\n  traverse(sourceFile)\n\n  function addToTypes(name: string, arg: ts.Node) {\n    if (isSyntaxKind<ts.StringLiteral>(arg, SyntaxKind.StringLiteral)) {\n      const xtype = arg.text\n      if (xtype) {\n        types[name] = { xtype: `\"${xtype.toLowerCase()}\"` }\n      }\n    }\n    else if (isSyntaxKind<ts.Identifier>(arg, SyntaxKind.Identifier)) {\n      types[name] = { xclass: `\"${arg.text}\"` }\n    }\n  }\n\n  function traverse(node: ts.Node) {\n    if (isSyntaxKind<ts.ImportDeclaration>(node, SyntaxKind.ImportDeclaration)) {\n      // `node.moduleSpecifier` is always `StringLiteral` by language spec.\n      const moduleTokenName = (node.moduleSpecifier as ts.StringLiteral).text\n      if (moduleTokenName.match(REACTOR_MODULE_PATTERN) && node.importClause) {\n        if (isSyntaxKind<ts.NamespaceImport>(node.importClause.namedBindings, SyntaxKind.NamespaceImport)) {\n          // import * as reactor from '@extjs/reactor'\n          reactorNames.push(node.importClause.namedBindings.name.text)\n          reactifyNames = ['reactify']\n        }\n        else if (isSyntaxKind<ts.NamedImports>(node.importClause.namedBindings, SyntaxKind.NamedImports)) {\n          // import { reactify } from '@extjs/reactor'\n          const elements = node.importClause.namedBindings.elements\n          const reactifyNodes = elements.filter(e => {\n            return (e.propertyName && e.propertyName.text === REACTIFY) || (e.name.text === REACTIFY)\n          })\n          reactifyNames.push(...reactifyNodes.map(n => {\n            return n.name.text\n          }))\n        }\n      }\n      else if (moduleTokenName.match(COMPONENT_MODULE_PATTERN) && node.importClause) {\n        // import { Grid } from '@extjs/reactor/?\n        if (isSyntaxKind<ts.NamedImports>(node.importClause.namedBindings, SyntaxKind.NamedImports)) {\n          const elements = node.importClause.namedBindings.elements\n          for (let e of elements) {\n            const value = e.propertyName ? e.propertyName.text.toLowerCase() : e.name.text.toLowerCase()\n            types[e.name.text] = { xtype: `\"${value}\"` }\n          }\n        }\n      }\n    }\n    // Look for reactify calls. Keep track of the names of each component so we can map JSX tags to xtypes and\n    // convert props to configs so Sencha Cmd can discover automatic dependencies in the manifest.\n    else if (isSyntaxKind<ts.VariableDeclaration>(node, SyntaxKind.VariableDeclaration)) {\n      let call = isSyntaxKind<ts.CallExpression>(node.initializer, SyntaxKind.CallExpression) ?\n        // reactify(...)\n        node.initializer :\n        (isSyntaxKind<ts.AsExpression>(node.initializer, SyntaxKind.AsExpression) &&\n          isSyntaxKind<ts.CallExpression>(node.initializer.expression, SyntaxKind.CallExpression)) ?\n          // reactor.reactify(...)\n          node.initializer.expression :\n          undefined\n\n      if (call) {\n        if ((isSyntaxKind<ts.PropertyAccessExpression>(call.expression, SyntaxKind.PropertyAccessExpression) &&\n          isSyntaxKind<ts.Identifier>(call.expression.expression, SyntaxKind.Identifier) &&\n          ~reactorNames.indexOf(call.expression.expression.text) &&\n          ~reactifyNames.indexOf(call.expression.name.text)) ||\n          (isSyntaxKind<ts.Identifier>(call.expression, SyntaxKind.Identifier) &&\n            ~reactifyNames.indexOf((call.expression as ts.Identifier).text))) {\n          if (isSyntaxKind<ts.Identifier>(node.name, SyntaxKind.Identifier)) {\n            // example: const Grid = reactify('grid');\n            const varName = node.name.text\n            const arg = call.arguments[0]\n            if (arg) {\n              addToTypes(varName, arg)\n            }\n          }\n          else if (isSyntaxKind<ts.ArrayBindingPattern>(node.name, SyntaxKind.ArrayBindingPattern)) {\n            // example: const [ Grid, Panel ] = reactify('grid', SomePanel);\n            for (let i = 0; i < node.name.elements.length; i++) {\n              const element = node.name.elements[i]\n              if (isSyntaxKind<ts.BindingElement>(element, SyntaxKind.BindingElement) &&\n                isSyntaxKind<ts.Identifier>(element.name, SyntaxKind.Identifier)) {\n                const tagName = element.name.text\n                const arg = call.arguments[i]\n                if (tagName && arg) {\n                  addToTypes(tagName, arg)\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    else if (isSyntaxKind<ts.JsxSelfClosingElement | ts.JsxOpeningElement>(node, SyntaxKind.JsxSelfClosingElement, SyntaxKind.JsxOpeningElement) &&\n      isSyntaxKind<ts.Identifier>(node.tagName, SyntaxKind.Identifier)) {\n      // convert reactified components to Ext.create calls to put in the manifest\n      const type = types[node.tagName.text]\n      if (type) {\n        const configs = { ...type };\n        for (let attribute of node.attributes) {\n          if (isSyntaxKind<ts.JsxAttribute>(attribute, SyntaxKind.JsxAttribute)) {\n            const name = attribute.name.text\n            if (isSyntaxKind<ts.StringLiteral>(attribute.initializer, SyntaxKind.StringLiteral)) {\n              configs[name] = `\"${attribute.initializer.text}\"`\n            }\n            else if (isSyntaxKind<ts.JsxExpression>(attribute.initializer, SyntaxKind.JsxExpression)) {\n              const { expression } = attribute.initializer\n              if (expression) {\n                if (isSyntaxKind<ts.ObjectLiteralExpression | ts.ArrayLiteralExpression>(expression, SyntaxKind.ObjectLiteralExpression, SyntaxKind.ArrayLiteralExpression)) {\n                  configs[name] = expression.getText(sourceFile)\n                }\n              }\n            }\n          }\n        }\n\n        const values: string[] = []\n\n        for (let name in configs) {\n          values.push(`${name}: ${configs[name]}`)\n        }\n\n        statements.push(`Ext.create({${values.join(', ')}})`)\n      }\n    }\n    ts.forEachChild(node, traverse)\n  }\n\n  return statements;\n}\n\nfunction isSyntaxKind<T extends ts.Node>(node: ts.Node | undefined, ...kinds: SyntaxKind[]): node is T {\n  return !!node && kinds.some(k => k === node.kind)\n}\n"]}