{"version":3,"file":"extractFromTSX.js","sourceRoot":"","sources":["../src/extractFromTSX.ts"],"names":[],"mappings":";;;;;;;;;AAAA,+BAAgC;AAChC,yCAAuC;AAEvC,IAAM,QAAQ,GAAG,UAAU,CAAA;AAC3B,IAAM,sBAAsB,GAAG,mBAAmB,CAAA;AAClD,IAAM,wBAAwB,GAAG,qCAAqC,CAAA;AAEtE;;;;;GAKG;AACH,wBAAuC,MAAM,EAAE,YAA6B;IAC1E,kEAAkE;IAClE,IAAM,UAAU,GAAG,EAAE,CAAC,gBAAgB,CAAC,SAAS,EAAE,MAAM,EAAE,YAAY,CAAC,CAAA;IACvE,IAAM,UAAU,GAAa,EAAE,CAAA;IAC/B,IAAM,KAAK,GAAG,EAAE,CAAA;IAChB,IAAI,aAAuB,CAAA;IAC3B,QAAQ,CAAC,UAAU,CAAC,CAAA;IACpB,kBAAkB,IAAa;QAC7B,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,uBAAU,CAAC,iBAAiB,CAAC,CAAC,CAAC;YAC/C,IAAM,WAAW,GAAG,IAA4B,CAAA;YAChD,IAAM,eAAe,GAAI,WAAW,CAAC,eAAuB,CAAC,IAAI,CAAA;YACjE,EAAE,CAAC,CAAC,eAAe,CAAC,KAAK,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC;gBAClD,oBAAoB;gBACpB,EAAE,CAAC,CAAC,WAAW,CAAC,YAAY,IAAI,WAAW,CAAC,YAAY,CAAC,aAAa,CAAC,CAAC,CAAC;oBACvE,IAAM,QAAQ,GAAW,WAAW,CAAC,YAAY,CAAC,aAAqB,CAAC,QAAQ,CAAA;oBAChF,IAAM,aAAa,GAAG,QAAQ,CAAC,MAAM,CAAC,UAAA,CAAC;wBACrC,MAAM,CAAC,CAAC,CAAC,CAAC,YAAY,IAAI,CAAC,CAAC,YAAY,CAAC,IAAI,KAAK,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,QAAQ,CAAC,CAAA;oBAC3F,CAAC,CAAC,CAAA;oBACF,aAAa,GAAG,aAAa,CAAC,GAAG,CAAC,UAAA,CAAC;wBACjC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAA;oBACpB,CAAC,CAAC,CAAA;gBACJ,CAAC;YACH,CAAC;YAED,IAAI,CAAC,EAAE,CAAC,CAAC,eAAe,CAAC,KAAK,CAAC,wBAAwB,CAAC,CAAC,CAAC,CAAC;gBACzD,EAAE,CAAC,CAAC,WAAW,CAAC,YAAY,IAAI,WAAW,CAAC,YAAY,CAAC,aAAa,CAAC,CAAC,CAAC;oBACvE,IAAM,QAAQ,GAAW,WAAW,CAAC,YAAY,CAAC,aAAqB,CAAC,QAAQ,CAAA;oBAChF,GAAG,CAAC,CAAU,UAAQ,EAAR,qBAAQ,EAAR,sBAAQ,EAAR,IAAQ;wBAAjB,IAAI,CAAC,iBAAA;wBACR,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,EAAE,QAAI,CAAC,CAAC,YAAY,GAAG,CAAC,CAAC,YAAY,CAAC,IAAI,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,QAAG,EAAE,CAAA;qBACtH;gBACH,CAAC;YACH,CAAC;QACH,CAAC;QAGD,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,uBAAU,CAAC,mBAAmB,CAAC,CAAC,CAAC;YACtD,wCAAwC;YACxC,oBAAoB;YACpB,IAAM,CAAC,GAAG,IAA8B,CAAA;YACxC,EAAE,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;gBAClB,IAAI,IAAI,SAA+B,CAAA;gBACvC,EAAE,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,uBAAU,CAAC,cAAc,CAAC,CAAC,CAAC;oBACrD,IAAI,GAAG,CAAC,CAAC,WAAgC,CAAA;gBAC3C,CAAC;gBACD,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,WAAW,CAAC,IAAI,IAAI,uBAAU,CAAC,YAAY,IAAK,CAAC,CAAC,WAA+B,CAAC,UAAU,CAAC,IAAI,KAAK,uBAAU,CAAC,cAAc,CAAC,CAAC,CAAC;oBAC3I,IAAI,GAAI,CAAS,CAAC,WAAW,CAAC,UAAU,CAAA;gBAC1C,CAAC;gBAED,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;oBACT,EAAE,CAAC,CAAC,CAAC,aAAa,CAAC,OAAO,CAAE,IAAI,CAAC,UAA4B,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;wBACpE,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,uBAAU,CAAC,UAAU,CAAC,CAAC,CAAC;4BAC1C,0CAA0C;4BAC1C,IAAM,OAAO,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAA;4BAC3B,IAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAA;4BAC7B,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC;gCAAC,MAAM,CAAA;4BAEhB,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,KAAK,uBAAU,CAAC,aAAa,CAAC,CAAC,CAAC;gCAC1C,IAAM,KAAK,GAAI,GAAwB,CAAC,IAAI,CAAA;gCAC5C,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;oCACV,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,KAAK,EAAE,OAAI,KAAK,CAAC,WAAW,EAAE,OAAG,EAAE,CAAA;gCACxD,CAAC;4BACH,CAAC;4BACD,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,KAAK,uBAAU,CAAC,UAAU,CAAC,CAAC,CAAC;gCAC5C,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,MAAM,EAAE,OAAK,GAAqB,CAAC,IAAI,OAAG,EAAE,CAAA;4BACjE,CAAC;wBACH,CAAC;wBACD,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,uBAAU,CAAC,mBAAmB,CAAC,CAAC,CAAC;4BACxD,gEAAgE;4BAChE,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gCAChD,IAAM,OAAO,GAAK,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAS,CAAC,IAAsB,CAAC,IAAI,CAAA;gCACxE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC;oCAAC,QAAQ,CAAA;gCACtB,IAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAA;gCAC7B,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC;oCAAC,QAAQ,CAAA;gCAClB,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,KAAK,uBAAU,CAAC,aAAa,CAAC,CAAC,CAAC;oCAC1C,IAAM,KAAK,GAAI,GAAwB,CAAC,IAAI,CAAA;oCAC5C,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;wCACV,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,KAAK,EAAE,OAAI,KAAK,CAAC,WAAW,EAAE,OAAG,EAAE,CAAA;oCACxD,CAAC;gCACH,CAAC;gCACD,IAAI,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,IAAI,KAAK,uBAAU,CAAC,UAAU,CAAC,CAAC,CAAC;oCAC5C,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,MAAM,EAAE,OAAK,GAAqB,CAAC,IAAI,OAAG,EAAE,CAAA;gCACjE,CAAC;4BACH,CAAC;wBACH,CAAC;oBACH,CAAC;gBACH,CAAC;YACH,CAAC;QAGH,CAAC;QAED,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,uBAAU,CAAC,qBAAqB,IAAI,IAAI,CAAC,IAAI,KAAK,uBAAU,CAAC,iBAAiB,CAAC,CAAC,CAAC;YACtG,iCAAiC;YACjC,IAAM,CAAC,GAAI,IAAwD,CAAA;YACnE,IAAM,GAAG,GAAI,CAAC,CAAC,OAAyB,CAAC,IAAI,CAAA;YAC7C,oBAAoB;YACpB,IAAM,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,CAAA;YACvB,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBACT,IAAM,OAAO,gBAAQ,IAAI,CAAE,CAAC;gBAC5B,GAAG,CAAC,CAAkB,UAAY,EAAZ,KAAA,CAAC,CAAC,UAAU,EAAZ,cAAY,EAAZ,IAAY;oBAA7B,IAAI,SAAS,SAAA;oBAChB,EAAE,CAAC,CAAC,SAAS,CAAC,IAAI,KAAK,uBAAU,CAAC,YAAY,CAAC,CAAC,CAAC;wBAC/C,IAAM,MAAI,GAAG,SAAS,CAAC,IAAI,CAAC,IAAI,CAAA;wBAChC,EAAE,CAAC,CAAC,SAAS,CAAC,WAAW,CAAC,CAAC,CAAC;4BAC1B,EAAE,CAAC,CAAC,SAAS,CAAC,WAAW,CAAC,IAAI,KAAK,uBAAU,CAAC,aAAa,CAAC,CAAC,CAAC;gCAC5D,OAAO,CAAC,MAAI,CAAC,GAAG,OAAI,SAAS,CAAC,WAAW,CAAC,IAAI,OAAG,CAAA;4BACnD,CAAC;4BACD,IAAI,CAAC,EAAE,CAAC,CAAC,SAAS,CAAC,WAAW,CAAC,IAAI,KAAK,uBAAU,CAAC,aAAa,CAAC,CAAC,CAAC;gCACjE,qCAAqC;gCAC7B,IAAA,6CAAU,CAA0B;gCAC5C,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;oCACf,OAAO,CAAC,GAAG,CAAC,MAAI,EAAE,UAAU,CAAC,IAAI,CAAC,CAAA;oCAClC,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,KAAK,uBAAU,CAAC,WAAW,CAAC,CAAC,CAAC;wCAC/C,OAAO,CAAC,MAAI,CAAC,GAAG,IAAI,CAAA;oCACtB,CAAC;oCACD,IAAI,CAAC,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,KAAK,uBAAU,CAAC,YAAY,CAAC,CAAC,CAAC;wCACrD,OAAO,CAAC,MAAI,CAAC,GAAG,KAAK,CAAA;oCACvB,CAAC;oCACD,IAAI,CAAC,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,KAAK,uBAAU,CAAC,cAAc,CAAC,CAAC,CAAC;wCACvD,OAAO,CAAC,MAAI,CAAC,GAAI,UAAmC,CAAC,IAAI,CAAA;oCAC3D,CAAC;oCACD,IAAI,CAAC,EAAE,CAAC,CAAC,UAAU,CAAC,IAAI,KAAK,uBAAU,CAAC,uBAAuB;wCAC7D,UAAU,CAAC,IAAI,KAAK,uBAAU,CAAC,sBAAsB,CAAC,CAAC,CAAC;wCACxD,8CAA8C;wCAC9C,OAAO,CAAC,MAAI,CAAC,GAAG,UAAU,CAAC,OAAO,CAAC,UAAU,CAAC,CAAA;oCAEhD,CAAC;gCACH,CAAC;4BAcH,CAAC;wBACH,CAAC;oBACH,CAAC;iBACF;gBAED,uBAAuB;gBACvB,IAAM,MAAM,GAAa,EAAE,CAAC;gBAE5B,GAAG,CAAC,CAAC,IAAI,MAAI,IAAI,OAAO,CAAC,CAAC,CAAC;oBACzB,MAAM,CAAC,IAAI,CAAI,MAAI,UAAK,OAAO,CAAC,MAAI,CAAG,CAAC,CAAA;gBAC1C,CAAC;gBAED,UAAU,CAAC,IAAI,CAAC,iBAAe,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAI,CAAC,CAAC;YACxD,CAAC;QACH,CAAC;QACD,EAAE,CAAC,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAA;IACjC,CAAC;IAED,MAAM,CAAC,UAAU,CAAC;AACpB,CAAC;;AA/JD,iCA+JC;AAAA,CAAC","sourcesContent":["import * as ts from 'typescript'\nimport { SyntaxKind } from 'typescript'\n\nconst REACTIFY = 'reactify'\nconst REACTOR_MODULE_PATTERN = /^@extjs\\/reactor$/\nconst COMPONENT_MODULE_PATTERN = /^@extjs\\/reactor\\/(modern|classic)$/\n\n/**\n * Extracts Ext.create equivalents from jsx tags so that cmd knows which classes to include in the bundle\n * @param {String} js The javascript code\n * @param {String} prefix The prefix that denotes an Ext JS xtype\n * @returns {Array} An array of Ext.create statements\n */\nexport default function extractFromTSX(source, scriptTarget: ts.ScriptTarget) {\n  // need to specify the filename as *.tsx for tsc to parse JSX tags\n  const sourceFile = ts.createSourceFile('foo.tsx', source, scriptTarget)\n  const statements: string[] = []\n  const types = {}\n  let reactifyNames: string[]\n  traverse(sourceFile)\n  function traverse(node: ts.Node) {\n    if (node.kind === SyntaxKind.ImportDeclaration) {\n      const declaration = node as ts.ImportDeclaration\n      const moduleTokenName = (declaration.moduleSpecifier as any).text\n      if (moduleTokenName.match(REACTOR_MODULE_PATTERN)) {\n        // console.log(node)\n        if (declaration.importClause && declaration.importClause.namedBindings) {\n          const elements: any[] = (declaration.importClause.namedBindings as any).elements\n          const reactifyNodes = elements.filter(e => {\n            return (e.propertyName && e.propertyName.text === REACTIFY) || (e.name.text === REACTIFY)\n          })\n          reactifyNames = reactifyNodes.map(n => {\n            return n.name.text\n          })\n        }\n      }\n      // look for: import { Grid } from '@extjs/reactor/?\n      else if (moduleTokenName.match(COMPONENT_MODULE_PATTERN)) {\n        if (declaration.importClause && declaration.importClause.namedBindings) {\n          const elements: any[] = (declaration.importClause.namedBindings as any).elements\n          for (let e of elements) {\n            types[e.name.text] = { xtype: `\"${e.propertyName ? e.propertyName.text.toLowerCase() : e.name.text.toLowerCase()}\"` }\n          }\n        }\n      }\n    }\n    // Look for reactify calls. Keep track of the names of each component so we can map JSX tags to xtypes and\n    // convert props to configs so Sencha Cmd can discover automatic dependencies in the manifest.\n    else if (node.kind === SyntaxKind.VariableDeclaration) {\n      // console.log(node.getText(sourceFile))\n      // console.log(node)\n      const d = node as ts.VariableDeclaration\n      if (d.initializer) {\n        let call: ts.CallExpression | undefined\n        if (d.initializer.kind === SyntaxKind.CallExpression) {\n          call = d.initializer as ts.CallExpression\n        }\n        else if (d.initializer.kind == SyntaxKind.AsExpression && (d.initializer as ts.AsExpression).expression.kind === SyntaxKind.CallExpression) {\n          call = (d as any).initializer.expression\n        }\n\n        if (call) {\n          if (~reactifyNames.indexOf((call.expression as ts.Identifier).text)) {\n            if (d.name.kind === SyntaxKind.Identifier) {\n              // example: const Grid = reactify('grid');\n              const varName = d.name.text\n              const arg = call.arguments[0]\n              if (!arg) return\n\n              if (arg.kind === SyntaxKind.StringLiteral) {\n                const xtype = (arg as ts.StringLiteral).text\n                if (xtype) {\n                  types[varName] = { xtype: `\"${xtype.toLowerCase()}\"` }\n                }\n              }\n              else if (arg.kind === SyntaxKind.Identifier) {\n                types[varName] = { xclass: `\"${(arg as ts.Identifier).text}\"` }\n              }\n            }\n            else if (d.name.kind === SyntaxKind.ArrayBindingPattern) {\n              // example: const [ Grid, Panel ] = reactify('grid', SomePanel);\n              for (let i = 0; i < d.name.elements.length; i++) {\n                const tagName = ((d.name.elements[i] as any).name as ts.Identifier).text\n                if (!tagName) continue\n                const arg = call.arguments[i]\n                if (!arg) continue\n                if (arg.kind === SyntaxKind.StringLiteral) {\n                  const xtype = (arg as ts.StringLiteral).text\n                  if (xtype) {\n                    types[tagName] = { xtype: `\"${xtype.toLowerCase()}\"` }\n                  }\n                }\n                else if (arg.kind === SyntaxKind.Identifier) {\n                  types[tagName] = { xclass: `\"${(arg as ts.Identifier).text}\"` }\n                }\n              }\n            }\n          }\n        }\n      }\n      // console.log(node)\n      // console.log(types)\n    }\n    // convert reactified components to Ext.create calls to put in the manifest\n    else if (node.kind === SyntaxKind.JsxSelfClosingElement || node.kind === SyntaxKind.JsxOpeningElement) {\n      // console.log(`JSX found`, node)\n      const e = (node as ts.JsxSelfClosingElement | ts.JsxOpeningElement)\n      const tag = (e.tagName as ts.Identifier).text\n      // console.log(node)\n      const type = types[tag]\n      if (type) {\n        const configs = { ...type };\n        for (let attribute of e.attributes) {\n          if (attribute.kind === SyntaxKind.JsxAttribute) {\n            const name = attribute.name.text\n            if (attribute.initializer) {\n              if (attribute.initializer.kind === SyntaxKind.StringLiteral) {\n                configs[name] = `\"${attribute.initializer.text}\"`\n              }\n              else if (attribute.initializer.kind === SyntaxKind.JsxExpression) {\n                // console.log(attribute.initializer)\n                const { expression } = attribute.initializer\n                if (expression) {\n                  console.log(name, expression.kind)\n                  if (expression.kind === SyntaxKind.TrueKeyword) {\n                    configs[name] = true\n                  }\n                  else if (expression.kind === SyntaxKind.FalseKeyword) {\n                    configs[name] = false\n                  }\n                  else if (expression.kind === SyntaxKind.NumericLiteral) {\n                    configs[name] = (expression as ts.LiteralExpression).text\n                  }\n                  else if (expression.kind === SyntaxKind.ObjectLiteralExpression ||\n                    expression.kind === SyntaxKind.ArrayLiteralExpression) {\n                    // console.log(expression.getText(sourceFile))\n                    configs[name] = expression.getText(sourceFile)\n                    // console.log(configs[name])\n                  }\n                }\n                // if (expression && expression.kind === SyntaxKind.FunctionExpression) {\n                //   configs[name] = (expression as any).text\n                // }\n                // try {\n                //     const { expression } = valueNode;\n\n                //     if (expression.type.indexOf('Function') === -1) {\n                //         let js = astring(valueNode.expression);\n                //         configs[name] = js;\n                //     }\n                // } catch (e) {\n                //     // will get here if the value contains jsx or something else that can't be converted back to js\n                // }\n              }\n            }\n          }\n        }\n\n        // console.log(configs)\n        const values: string[] = [];\n\n        for (let name in configs) {\n          values.push(`${name}: ${configs[name]}`)\n        }\n\n        statements.push(`Ext.create({${values.join(', ')}})`);\n      }\n    }\n    ts.forEachChild(node, traverse)\n  }\n\n  return statements;\n};\n"]}